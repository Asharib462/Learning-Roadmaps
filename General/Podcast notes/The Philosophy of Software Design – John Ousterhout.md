
| #  | Growth principle illustrated                            | What Ousterhout said / did                                                                                                                                               | How to apply it to **improve as a programmer**                                                                                                                                                                                                       |
| -- | ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1  | **Expect the job to change; invest ahead of the curve** | AI will “churn out more and more low-level code… so developers will spend a larger fraction of their time on *design*” (00:37–00:49).                                    | • Shift learning time from syntax & APIs to architectural thinking, abstraction, and complexity management.<br>• When practicing, deliberately choose exercises that require decomposing a messy problem, not just writing algorithms.               |
| 2  | **Fight complexity first**                              | “Design is all about managing complexity… first eliminate special cases, then hide what remains” (19:54–20:03).                                                          | • In every code review ask: *Can this case be impossible instead of handled?*<br>• Refactor until the ‘happy path’ dominates and exceptional paths are rare or isolated.                                                                             |
| 3  | **Iterate—“Design it twice”**                           | Students forced to invent a second approach always produced better designs; his own TK widget API came from the *second* design sketched on a long flight (20:54–21:14). | • Before committing code, spend 15 minutes writing a radically different sketch (different data shape, protocol, or decomposition).<br>• Maintain a “scratch/alt” folder to incubate these variants.                                                 |
| 4  | **Beware the “Tactical Tornado” mindset**               | Fast coders who “pump out features but leave a wave of destruction” hurt teams long-term (08:54–09:19).                                                                  | • Track *cleanup debt* you create; schedule refactors in the same sprint.<br>• During PR review, require each change to include a test and documentation delta, not just code.                                                                       |
| 5  | **Depth over breadth (deep modules)**                   | Deep module = tiny interface, lots of hidden power; shallow = fat API, little logic (17:30–18:00).                                                                       | • Audit your code: count public methods vs. internal LOC. Merge or refactor modules that expose many public knobs but do little.<br>• Write unit tests *only* against the narrow interface—if tests need internals you’ve designed a shallow module. |
| 6  | **Reduce exceptions, don’t just handle them**           | Each extra error case raises cognitive load; strive to “define errors out of existence” (24:28–25:05).                                                                   | • Adopt fail-fast defaults (e.g., immutable objects, total functions) so many invalid states cannot occur.<br>• Standardize a *single* error-handling strategy per subsystem (e.g., Go-style result+error or exceptions, not both).                  |
| 7  | **Seek ruthless feedback & rewrite**                    | He individually marks up every student’s code—50–100 comments per team—and the *rewrite* phase is where learning spikes (42:46–44:00).                                   | • Pair-review with a senior dev and insist on a follow-up PR that addresses every comment.<br>• After merging, schedule a post-mortem mini-blog summarizing what you rewrote and why.                                                                |
| 8  | **Empathy is a design tool**                            | Good designers “change mindset and view the module from the caller’s perspective” (34:10–34:40).                                                                         | • Write the README/API doc *before* the code; if the doc feels clumsy, redesign.<br>• During code review, reviewers role-play “first-time caller” and list all implicit assumptions.                                                                 |
| 9  | **Code comments for the invisible**                     | Interfaces and member variables need prose; code alone cannot express invariants or performance assumptions (58:18–59:30).                                               | • Document why a thing exists, the invariants it maintains, and cost expectations (e.g., O(1) vs O(n)).<br>• Add a `// WHY:` block above non-obvious decisions; future devs (and AI tools) can’t infer intent.                                       |
| 10 | **Balance testing with design (TDD skepticism)**        | Writing tests *first* can drive overly tactical, special-case designs (55:00–55:30).                                                                                     | • Write a slim design sketch first; then author tests that exercise the design’s public surface.<br>• For bug fixes, do create the failing test *before* the patch to lock regression behavior.                                                      |

---

### Quick practice plan (4 weeks)

| Week | Daily micro-habit (15 min)                                   | Weekly deep work (90 min)                                                                                    |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |
| 1    | Sketch a *second* solution for any feature/bug you touch.    | Pick one of your modules and shrink its public API by 25 %.                                                  |
| 2    | Add a `WHY` comment for every new file or public function.   | Delete or merge 2 “shallow” helper classes into deeper ones.                                                 |
| 3    | Before coding, whiteboard a caller-centric sequence diagram. | Rewrite an old function to eliminate one error case entirely.                                                |
| 4    | After each PR review, jot 3 lessons in a personal log.       | Refactor a small service to isolate “tactical tornado” code; schedule automated tests for the deep API only. |

Stick with these loops and you’ll be practicing exactly the growth behaviors Ousterhout drills into his Stanford course—preparing you for a world where design, not keystrokes, is the main differentiator.
